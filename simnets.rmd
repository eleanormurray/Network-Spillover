---
title: "Toy Network Models"
output: html_document
date: '2022-07-18'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
require("EpiModel")
require("igraph")
require("foreach")
require("doParallel")
require("reticulate")
require(dplyr)
require(ggplot2)
require(desplot)
require(patchwork)
require(purrr)
require(furrr)
require(tidyverse)
require(RColorBrewer)
# plan("multisession", workers=24)
set.seed(100)
options(future.rng.onMisuse="ignore")
```

```{r params}
N<-20 #network population/ graph order
eprob<-0.1 #edge formation probability for ER model 
phiv<-0.1 # underlying hiv prevalence
PrEP1<-0.1 # PrEP assignment coverage in control treatment (a) 
PrEP2<-0.2 # PrEP assignment coverage in counterfactual treatment (a*)
#HIV risk by contact and PrEP allocation p
p1<-0.2 #P(HIV|Contact and -PrEP)
p2<-0.1 #P(HIV|Contact and PrEP)
nsim<-100
plots=T
scale="additive"
```

```{r simulation original}
sim<-function(N=20,eprob=0.1,phiv=0.1,PrEP1=0.1,PrEP2=0.2, p1=0.2,p2=0.1, plots=F, scale="additive"){
  #parameter check
# plot a random graph, 3 color options
#control scenario graph, 10% assignment prob
g <- sample_gnp(N,eprob)
vertex_attr(g) <- list(color =c(rep("red", gorder(g)*phiv), rep("blue",gorder(g)*PrEP1), rep("black", gorder(g)*(1-(phiv+PrEP1)))))
if(plots){plot(g, vertex.size=10,vertex.label.cex=1, vertex.label.dist=2,main="Control")}
df_g<-as_long_data_frame(g)
colnames(df_g)<-c("from","to","color1","color2")
#compute P(HIV|PrEP)
treat_g<-subset(df_g, (df_g$color1=="blue"|df_g$color2=="blue"))
treat_inf_contact_g<-subset(treat_g, treat_g$color1=="red"|treat_g$color2=="red")
hiv_given_prep_g<-ifelse(nrow(treat_g)!=0,(nrow(treat_inf_contact_g)*p2)/nrow(treat_g),0)
#Compute P(HIV|-PrEP)
no_treat_g<-subset(df_g, df_g$color1!="blue"&df_g$color2!="blue")
no_treat_inf_contact_g<-subset(no_treat_g, no_treat_g$color1=="red"|no_treat_g$color2=="red")
# hiv_given_no_prep_g<-nrow(no_treat_inf_contact_g)/nrow(no_treat_g)
hiv_given_no_prep_g<-ifelse(nrow(no_treat_g)!=0,(nrow(no_treat_inf_contact_g)*p1)/nrow(no_treat_g),0)
#Randomly assign 20% overall (shuffle attributes)
l1<-round(gorder(g)*(1-(phiv+PrEP2)),0)
h<-set_vertex_attr(g,"color",value=gtools::permute(c(rep("red", gorder(g)*phiv), rep("blue",gorder(g)*PrEP2), rep("black", l1))))
if(plots){plot(h,  vertex.size=10,vertex.label.cex=1, vertex.label.dist=2,main="Random overall")}
df_h<-as_long_data_frame(h)
colnames(df_h)<-c("from","to","color1","color2")
#Compute P(HIV|PrEP)
treat_h<-subset(df_h, (df_h$color1=="blue"|df_h$color2=="blue"))
treat_inf_contact_h<-subset(treat_h, treat_h$color1=="red"|treat_h$color2=="red")
hiv_given_prep_h<-ifelse(nrow(treat_h)!=0,(nrow(treat_inf_contact_h)*p2)/nrow(treat_h),0)
#Compute P(HIV|-PrEP)
no_treat_h<-subset(df_h, df_h$color1!="blue"&df_h$color2!="blue")
no_treat_inf_contact_h<-subset(no_treat_h, no_treat_h$color1=="red"|no_treat_h$color2=="red")
hiv_given_no_prep_h<-ifelse(nrow(no_treat_h)!=0,(nrow(no_treat_inf_contact_h)*p1)/nrow(no_treat_h),0)
#duplicate network structure, additional 10% treated
l2<-round(gorder(g)*(1-(phiv+PrEP2)),0)
j<-set_vertex_attr(g,"color",value=c(rep("red", gorder(g)*phiv), rep("blue",gorder(g)*PrEP2), rep("black", l2)))
if(plots){plot(j,  vertex.size=10,vertex.label.cex=1, vertex.label.dist=2,main="Random additional")}
df_j<-as_long_data_frame(j)
colnames(df_j)<-c("from","to","color1","color2")
#compute (HIV|PrEP)
treat_j<-subset(df_j, (df_j$color1=="blue"|df_j$color2=="blue"))
treat_inf_contact_j<-subset(treat_j, treat_j$color1=="red"|treat_j$color2=="red")
hiv_given_prep_j<-ifelse(nrow(treat_j)!=0,(nrow(treat_inf_contact_j)*p2)/nrow(treat_j),0)
#Compute P(HIV|-PrEP)
no_treat_j<-subset(df_j, df_j$color1!="blue"&df_j$color2!="blue")
no_treat_inf_contact_j<-subset(no_treat_j, no_treat_j$color1=="red"|no_treat_j$color2=="red")
hiv_given_no_prep_j<-ifelse(nrow(no_treat_j)!=0,(nrow(no_treat_inf_contact_j)*p1)/nrow(no_treat_j),0)
# plot a random graph, 3 color options
k <- sample_gnp(N,eprob)
vertex_attr(k) <- list(color =c(rep("red", gorder(k)*phiv), rep("blue",gorder(k)*PrEP1), rep("black", gorder(k)*(1-(phiv+PrEP1)))))
if(plots){plot(k,  vertex.size=10,vertex.label.cex=1, vertex.label.dist=2,main="Regenerated")}
df_k<-as_long_data_frame(k)
colnames(df_k)<-c("from","to","color1","color2")
#Compute P(HIV|PrEP)
treat_k<-subset(df_k, (df_k$color1=="blue"|df_k$color2=="blue"))
treat_inf_contact_k<-subset(treat_k, treat_k$color1=="red"|treat_k$color2=="red")
hiv_given_prep_k<-ifelse(nrow(treat_k)!=0,(nrow(treat_inf_contact_k)*p2)/nrow(treat_k),0)
#Compute P(HIV|-PrEP)
no_treat_k<-subset(df_k, df_k$color1!="blue"&df_k$color2!="blue")
no_treat_inf_contact_k<-subset(no_treat_k, no_treat_k$color1=="red"|no_treat_k$color2=="red")
hiv_given_no_prep_k<-ifelse(nrow(no_treat_k)!=0,(nrow(no_treat_inf_contact_k)*p1)/nrow(no_treat_k),0)
# Combine effect estimates
prep<-c(hiv_given_prep_g,hiv_given_prep_h,hiv_given_prep_j,hiv_given_prep_k)
names(prep)<-c("hiv_given_prep_g","hiv_given_prep_h","hiv_given_prep_j","hiv_given_prep_k")
no_prep<-c(hiv_given_no_prep_g,hiv_given_no_prep_h,hiv_given_no_prep_j,hiv_given_no_prep_k)
names(no_prep)<-c("hiv_given_no_prep_g","hiv_given_no_prep_h","hiv_given_no_prep_j","hiv_given_no_prep_k")
ef<-prep+no_prep
names(ef)<-c("control,",paste("ran", PrEP2*100, sep=""),paste("add",((PrEP2-PrEP1)*100), sep=""),"regen")
#compute causal contrasts
if(scale=="additive"){cc<-as.data.frame(t(ef[-1]-ef[1]))} 
# else if(scale=="multiplicative"){ef<-ef+1;
# cc<-as.data.frame(t(ef[-1])/ef[1]); 
#if(is.na(t(ef[-1]/ef[1]))||is.infinite(t(ef[-1]/ef[1]))){print(ef)}
# }
names(cc)<-c(paste("ran", PrEP2*100, sep=""),paste("add",((PrEP2-PrEP1)*100), sep=""),"regen")
res<-cbind(N,eprob,phiv,PrEP1,PrEP2,p1,p2,as.data.frame(t(prep)),as.data.frame(t(no_prep)),cc)
names(res)<-c("N","eprob","phiv", "PrEP1","PrEP2","p1","p2",names(prep), names(no_prep),names(cc))
return(res)}
```



```{r simulation parallel}
sim_par<-function(N=20,eprob=0.1,phiv=0.1,PrEP1=0.1,PrEP2=0.2, p1=0.2,p2=0.1, nsim=100, scale="additive"){
res<-future_map_dfr(1:nsim,~sim(N=N,eprob=eprob,phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2, p1=p1,p2=p2, scale=scale))
  # function(N=20,eprob=0.1,phiv=0.1,PrEP1=0.1,PrEP2=0.2, p1=0.2,p2=0.1){
# # plot a random graph, 3 color options
# #control scenario graph, 10% assignment prob
# g <- sample_gnp(N,eprob) 
# vertex_attr(g) <- list(color =c(rep("red", gorder(g)*phiv), rep("blue",gorder(g)*PrEP1), rep("black", gorder(g)*(1-(phiv+PrEP1)))))
# df_g<-as_long_data_frame(g)
# colnames(df_g)<-c("from","to","color1","color2")
# #compute P(HIV|PrEP)
# treat_g<-subset(df_g, (df_g$color1=="blue"|df_g$color2=="blue"))
# treat_inf_contact_g<-subset(treat_g, treat_g$color1=="red"|treat_g$color2=="red")
# hiv_given_prep_g<-ifelse(nrow(treat_g)!=0,(nrow(treat_inf_contact_g)*p2)/nrow(treat_g),0)
# #Compute P(HIV|-PrEP)
# no_treat_g<-subset(df_g, df_g$color1!="blue"&df_g$color2!="blue")
# no_treat_inf_contact_g<-subset(no_treat_g, no_treat_g$color1=="red"|no_treat_g$color2=="red")
# hiv_given_no_prep_g<-ifelse(nrow(no_treat_g)!=0,(nrow(no_treat_inf_contact_g)*p1)/nrow(no_treat_g),0)
# #Randomly assign 20% overall (shuffle attributes)
# h<-set_vertex_attr(g,"color",value=gtools::permute(c(rep("red", gorder(g)*phiv), rep("blue",gorder(g)*PrEP2), rep("black", gorder(g)*(1-(phiv+PrEP2))))))
# df_h<-as_long_data_frame(h)
# colnames(df_h)<-c("from","to","color1","color2")
# #Compute P(HIV|PrEP)
# treat_h<-subset(df_h, (df_h$color1=="blue"|df_h$color2=="blue"))
# treat_inf_contact_h<-subset(treat_h, treat_h$color1=="red"|treat_h$color2=="red")
# hiv_given_prep_h<-ifelse(nrow(treat_h)!=0,(nrow(treat_inf_contact_h)*p2)/nrow(treat_h),0)
# #Compute P(HIV|-PrEP)
# no_treat_h<-subset(df_h, df_h$color1!="blue"&df_h$color2!="blue")
# no_treat_inf_contact_h<-subset(no_treat_h, no_treat_h$color1=="red"|no_treat_h$color2=="red")
# hiv_given_no_prep_h<-ifelse(nrow(no_treat_h)!=0,(nrow(no_treat_inf_contact_h)*p1)/nrow(no_treat_h),0)
# #duplicate network structure, additional 10% treated 
# j<-set_vertex_attr(g,"color",value=c(rep("red", gorder(g)*phiv), rep("blue",gorder(g)*PrEP2), rep("black", gorder(g)*(1-(phiv+PrEP2)))))
# df_j<-as_long_data_frame(j)
# colnames(df_j)<-c("from","to","color1","color2")
# #compute (HIV|PrEP)
# treat_j<-subset(df_j, (df_j$color1=="blue"|df_j$color2=="blue"))
# treat_inf_contact_j<-subset(treat_j, treat_j$color1=="red"|treat_j$color2=="red")
# hiv_given_prep_j<-ifelse(nrow(treat_j)!=0,(nrow(treat_inf_contact_j)*p2)/nrow(treat_j),0)
# #Compute P(HIV|-PrEP)
# no_treat_j<-subset(df_j, df_j$color1!="blue"&df_j$color2!="blue")
# no_treat_inf_contact_j<-subset(no_treat_j, no_treat_j$color1=="red"|no_treat_j$color2=="red")
# hiv_given_no_prep_j<-ifelse(nrow(no_treat_j)!=0,(nrow(no_treat_inf_contact_j)*p1)/nrow(no_treat_j),0)
# # plot a random graph, 3 color options
# k <- sample_gnp(N,eprob)
# vertex_attr(k) <- list(color =c(rep("red", gorder(k)*phiv), rep("blue",gorder(k)*PrEP1), rep("black", gorder(k)*(1-(phiv+PrEP1)))))
# df_k<-as_long_data_frame(k)
# colnames(df_k)<-c("from","to","color1","color2")
# #Compute P(HIV|PrEP)
# treat_k<-subset(df_k, (df_k$color1=="blue"|df_k$color2=="blue"))
# treat_inf_contact_k<-subset(treat_k, treat_k$color1=="red"|treat_k$color2=="red")
# hiv_given_prep_k<-ifelse(nrow(treat_k)!=0,(nrow(treat_inf_contact_k)*p2)/nrow(treat_k),0)
# #Compute P(HIV|-PrEP)
# no_treat_k<-subset(df_k, df_k$color1!="blue"&df_k$color2!="blue")
# no_treat_inf_contact_k<-subset(no_treat_k, no_treat_k$color1=="red"|no_treat_k$color2=="red")
# hiv_given_no_prep_k<-ifelse(nrow(no_treat_k)!=0,(nrow(no_treat_inf_contact_k)*p1)/nrow(no_treat_k),0)
# # Combine effect estimates
# prep<-c(hiv_given_prep_g,hiv_given_prep_h,hiv_given_prep_j,hiv_given_prep_k)
# no_prep<-c(hiv_given_no_prep_g,hiv_given_no_prep_h,hiv_given_no_prep_j,hiv_given_no_prep_k)
# ef<-prep+no_prep
# names(ef)<-c("control,",paste("ran", PrEP2*100, sep=""),paste("ran", PrEP1*100,"+",PrEP1*100, sep=""),"regen")
# cc<-as.data.frame(t(ef[-1]-ef[1]))
# names(cc)<-c(paste("ran", PrEP2*100, sep=""),paste("ran", PrEP1*100,"+",PrEP1*100, sep=""),"regen")
# res<-cbind(N,eprob,phiv,PrEP1,PrEP2,p1,p2,cc)
# names(res)<-c("N","eprob","phiv", "PrEP1","PrEP2","p1","p2",names(cc))
# return(res)})
res<-cbind(res,nsim)
# names(res)<-c(names(res),"nsim")
return(res)}
```

Trying to parallellize sim rather than use simpar, use rerun from purrr?
Don't use rerun, use a map with sim_par?

```{r}

# testing<-rerun(nsim,future_map_dfr(params,sim))
# testing<-future_pmap_dfr(params,sim_par)
# test_slice<-testing%>%group_by(p1,p2)%>%slice(1:nsim)
col_list=c(paste("ran", PrEP2*100, sep=""),paste("add",((PrEP2-PrEP1)*100), sep=""),"regen")
# test_means<-testing%>%group_by(N,p1,p2)%>%summarise(across(col_list,mean))
```




Check sensitivity to network size, plot heatmap by N

```{r}
params_N<-tidyr::expand_grid(N=c(20,200),phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2,p1=seq(0.1,1,0.1),p2=seq(0.1,1,0.1), nsim=nsim, scale="additive")
future::plan(
      list(
        future::tweak(
          future::multisession, 
          workers = 2), 
        future::tweak(
          future::multisession,
          workers = 12)
        )
      )
res_N<-future_pmap_dfr(params_N,sim_par)
means_N<-res_N%>%group_by(N,p1,p2)%>%summarise(across(all_of(col_list),mean))
```


```{r}
N_plot1<-ggplot(means_N,aes_string(x="p1",y="p2", fill=col_list[1]))+geom_tile()+viridis::scale_fill_viridis(discrete=F,limits=c(-1,1))+facet_grid(~N)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
N_plot2<-ggplot(means_N,aes_string(x="p1",y="p2", fill=col_list[2]))+geom_tile()+viridis::scale_fill_viridis(discrete=F,limits=c(-1,1))+facet_grid(~N)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
N_plot3<-ggplot(means_N,aes_string(x="p1",y="p2", fill=col_list[3]))+geom_tile()+viridis::scale_fill_viridis(discrete=F,limits=c(-1,1))+facet_grid(~N)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
N_plot1/N_plot2/N_plot3
```

```{r}
N_plot1
N_plot2
N_plot3
```
check sensitivity to sample size-cluster?

```{r}
params_samp<-expand.grid(N=20,phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2,p1=seq(0.1,1,0.1),p2=seq(0.1,1,0.1),nsim=10^seq(2,4,1))
future::plan(
      list(
        future::tweak(
          future::multisession, 
          workers = 4), 
        future::tweak(
          future::multisession,
          workers = 6)
        )
      )
res_samp<-future_pmap_dfr(params_samp,sim_par)
means_samp<-res_samp%>%group_by(nsim,p1,p2)%>%summarise(across(col_list,mean))
```

```{r}
samp_ran1<-ggplot(means_samp,aes_string(x="p1",y="p2",fill=col_list[1]))+geom_tile()+facet_grid(~nsim)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
samp_ran2<-ggplot(means_samp,aes_string(x="p1",y="p2",fill=col_list[2]))+geom_tile()+facet_grid(~nsim)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
samp_regen<-ggplot(means_samp,aes_string(x="p1",y="p2",fill=col_list[3]))+geom_tile()+facet_grid(~nsim)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
```

```{r}
samp_ran1/samp_ran2/samp_regen
```

increase underlying HIV prevalence phiv

```{r}
#check rounding issues!
params_phiv<-expand.grid(N=20,phiv=seq(0.1,0.7,0.1),PrEP1=PrEP1,PrEP2=PrEP2,p1=seq(0.1,1,0.1),p2=seq(0.1,1,0.1),nsim=200)
future::plan(
      list(
        future::tweak(
          future::multisession, 
          workers = 3), 
        future::tweak(
          future::multisession,
          workers = 8)
        )
      )
res_phiv<-future_pmap_dfr(params_phiv,sim_par)
means_phiv<-res_phiv%>%group_by(phiv,p1,p2)%>%summarise(across(col_list,mean))
```

```{r}
phiv_ran1<-ggplot(means_phiv,aes_string(x="p1",y="p2",fill=col_list[1]))+geom_tile()+facet_grid(~phiv)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
phiv_ran2<-ggplot(means_phiv,aes_string(x="p1",y="p2",fill=col_list[2]))+geom_tile()+facet_grid(~phiv)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
phiv_regen<-ggplot(means_phiv,aes_string(x="p1",y="p2",fill=col_list[3]))+geom_tile()+facet_grid(~phiv)+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
# phiv_ran1+scale_fill_gradientn(colors=brewer.pal(5,name="RdYlBu"))
phiv_ran1/phiv_ran2/phiv_regen
```

Increasing p1 only

```{r}
params_p1<-expand_grid(N=20,phiv=0.1,PrEP1=PrEP1,PrEP2=PrEP2,p1=seq(0.1,1,0.01),p2=0.1,nsim=200)
future::plan(
      list(
        future::tweak(
          future::multisession, 
          workers = 2), 
        future::tweak(
          future::multisession,
          workers = 12)
        )
      )
res_p1<-future_pmap_dfr(params_p1,sim_par)
means_p1<-res_p1%>%group_by(p1,p2)%>%summarise(across(col_list,mean))
```


```{r}
p1_ran1<-ggplot(means_p1,aes_string(x="p1",y=col_list[1]))+geom_point()#+scale_y_continuous(limits=c(-0.5,0.5))
p1_ran2<-ggplot(means_p1,aes_string(x="p1",y=col_list[2]))+geom_point()#+scale_y_continuous(limits=c(-1,1))
p1_ran3<-ggplot(means_p1,aes_string(x="p1",y=col_list[3]))+geom_point()#+scale_y_continuous(limits=c(-1,1))
```

```{r}
p1_ran1/p1_ran2/p1_ran3
p1_ran1
p1_ran2
p1_ran3
```

Increasing p2 only

```{r}
params_p2<-expand_grid(N=20,phiv=0.1,PrEP1=PrEP1,PrEP2=PrEP2,p2=seq(0.1,1,0.01),p1=0.1,nsim=200)
res_p2<-future_pmap_dfr(params_p2,sim_par)
means_p2<-res_p2%>%group_by(p2,p1)%>%summarise(across(col_list,mean))
```

```{r}
p2_ran1<-ggplot(means_p2,aes_string(x="p2",y=col_list[1]))+geom_point()#+scale_y_continuous(limits=c(-0.5,0.5))
p2_ran2<-ggplot(means_p2,aes_string(x="p2",y=col_list[2]))+geom_point()#+scale_y_continuous(limits=c(-1,1))
p2_ran3<-ggplot(means_p2,aes_string(x="p2",y=col_list[3]))+geom_point()#+scale_y_continuous(limits=c(-1,1))
```

```{r}
p2_ran1/p2_ran2/p2_ran3
```


Increasing PrEP1
```{r}
params_PrEP1<-expand_grid(N=20,phiv=0.1,PrEP1=seq(0.1,0.3,0.1),PrEP2=PrEP2,p1=seq(0.1,1,0.1),p2=seq(0.1,1,0.1),nsim=200)
future::plan(
      list(
        future::tweak(
          future::multisession, 
          workers = 3), 
        future::tweak(
          future::multisession,
          workers = 8)
        )
      )
res_PrEP1<-future_pmap_dfr(params_PrEP1,sim_par)
means_PrEP1<-res_PrEP1%>%group_by(p1,p2)%>%summarise(across(col_list,mean))
```

```{r}
PrEP1_ran1<-ggplot(means_PrEP1,aes_string(x="p1",y="p2",fill=col_list[1]))+geom_tile()+facet_grid(~PrEP1)
PrEP1_ran2<-ggplot(means_PrEP1,aes_string(x="p1",y="p2",fill=col_list[2]))+geom_tile()+facet_grid(~PrEP1)
PrEP1_regen<-ggplot(means_PrEP1,aes_string(x="p1",y="p2",fill=col_list[3]))+geom_tile()+facet_grid(~PrEP1)
```


```{r}
PrEP1_ran1
```


Increasing PrEP2 only





Below are failed attempts at parallelization DO NOT USE
```{r}
# # #sweep p1 only
# res3<-foreach(p1=seq(0.1,1,0.1) ) %:% foreach(icount(nsim), .combine=rbind) %dopar% {sim(N=N,eprob=eprob,phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2, p1=p1,p2=p2)}
# # #sweep p2 only
# res4<-foreach(p2=seq(0.1,1,0.1)) %:% foreach(icount(nsim), .combine=rbind) %dopar% {sim(N=N,eprob=eprob,phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2, p1=p1,p2=p2)}
```


```{r}
# l1<-as.list(seq(0.1,1,0.1))
# l2<-as.list(seq(0.1,1,0.1))
# res5<-foreach(p1=l1, .combine=rbind) %:% foreach(p2=l2, .combine=rbind) %do% {sim_par(N=N,eprob=eprob,phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2, p1=p1,p2=p2, nsim=100)}
```

```{r}
# params<-tidyr::expand_grid(N=c(20,200,2000,20000),phiv=phiv,PrEP1=PrEP1,PrEP2=PrEP2,p1=seq(0.1,1,0.1),p2=seq(0.1,1,0.1),nsim=nsim)
# res_grid<-purrr::pmap_dfr(params,sim_par)
# beepr::beep()
```


```{r}
# col_list<-names(res_grid)[4:6]
# # means<-res5%>%group_by(p1,p2)%>%summarise_each(mean,c(ran20, `ran10+10`,regen))
# means<-res_grid%>%group_by(N,p1,p2)%>%summarise(across(col_list,mean))
```









